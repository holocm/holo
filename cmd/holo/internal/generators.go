/*******************************************************************************
*
* Copyright 2020 Peter Werner <peter.wr@protonmail.com>
* Copyright 2021 Stefan Majewsky <majewsky@gmx.net>
*
* This file is part of Holo.
*
* Holo is free software: you can redistribute it and/or modify it under the
* terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
*
* Holo is distributed in the hope that it will be useful, but WITHOUT ANY
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
* A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* Holo. If not, see <http://www.gnu.org/licenses/>.
*
*******************************************************************************/

package impl

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/holocm/holo/internal/fs"
)

//Tracks which resource file was generated by which generator.
var generatorForResourceFile = map[string]string{}

//RunAllGenerators executes all generators in the /usr/share/holo/generators directory.
func RunAllGenerators() error {
	generatorsDir := filepath.Join(RootDirectory(), "/usr/share/holo/generators")
	return filepath.Walk(generatorsDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		//NOTE: We don't need to check for executability here. Having a
		//non-executable file in the generators directory just produces an obvious
		//error during exec.Command() down below.
		if info.Mode().IsRegular() {
			return runGenerator(path, filepathMustRel(generatorsDir, path))
		}
		return nil
	})
}

func runGenerator(generatorPath, generatorRelPath string) error {
	//prepare a cache directory with a unique name for the generator
	generatorID := sha256.Sum256([]byte(generatorPath))
	cacheDir := filepath.Join(CachePath(), hex.EncodeToString(generatorID[:]))
	err := os.Mkdir(cacheDir, 0777)
	if err != nil {
		return err
	}

	//prepare the generator's environment
	cmd := exec.Command(generatorPath)
	cmd.Env = append(os.Environ(),
		"HOLO_CACHE_DIR="+cacheDir,
		"HOLO_RESOURCE_ROOT="+filepath.Join(RootDirectory(), "/usr/share/holo"),
		"OUT="+VirtualResourceRoot(),
	)

	//run the generator
	out, err := cmd.CombinedOutput()
	for _, line := range strings.Split(string(out), "\n") {
		line = strings.TrimSpace(line)
		if line != "" {
			Warnf(Stderr, "output from %s: %s", generatorPath, line)
		}
	}
	if err != nil {
		return fmt.Errorf("could not run %s: %w", generatorPath, err)
	}

	//record which resource files were generated by this generator (we use this
	//later to rewrite logs regarding the generated resource file into a
	//reference to the generator)
	return filepath.Walk(VirtualResourceRoot(), func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		//we are only interested in files
		if info.Mode().IsDir() {
			return nil
		}
		//is this a new file?
		relPath, _ := filepath.Rel(VirtualResourceRoot(), path)
		_, exists := generatorForResourceFile[relPath]
		if !exists {
			generatorForResourceFile[relPath] = generatorRelPath
		}
		return nil
	})
}

//FinalizeVirtualResourceRoot copies into VirtualResourceRoot() all static
//resource files not overwritten by a generated resource file.
func FinalizeVirtualResourceRoot() error {
	physicalRoot := filepath.Join(RootDirectory(), "/usr/share/holo")
	virtualRoot := VirtualResourceRoot()

	return filepath.Walk(physicalRoot, func(physicalPath string, physicalInfo os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if physicalPath == physicalRoot {
			return nil
		}
		relPath, _ := filepath.Rel(physicalRoot, physicalPath)
		virtualPath := filepath.Join(virtualRoot, relPath)

		//symlinking entire directories would be more efficient, but confuses the
		//scanning phase of most plugins, so we recreate the entire directory
		//structure on the virtual side
		if physicalInfo.Mode().IsDir() {
			err = os.Mkdir(virtualPath, 0777)
			if err != nil && os.IsExist(err) {
				return nil
			}
			return err
		}

		//check if there is a generated resource file at this path
		_, err = os.Lstat(virtualPath)
		switch {
		case os.IsNotExist(err):
			//no generated resource file -> copy static resource file over
			//
			//NOTE: We also cannot symlink static resource files since symlinks have
			//special semantics in some plugins (most prominently in holo-files).
			generatorForResourceFile[relPath] = "" //not generated
			return fs.CopyFile(physicalPath, virtualPath, fs.CopyContentsAndExecutableBitOnly)
		case err != nil:
			return err
		default:
			//generated resource file -> takes precedence over static resource file
			return nil
		}
	})
}

//Like filepath.Rel(), but assumes that no error occurs. This assumption is
//safe if both inputs are absolute paths.
func filepathMustRel(base, target string) string {
	rel, _ := filepath.Rel(base, target)
	return rel
}

//TranslateIfResourcePath checks if the input is a path to a resource file from
//the virtual resource directory. If so, returns the human readable path for
//this resource file (referring to the physical resource directory for static
//resource files, or indicating the generator for generated resource files).
//Otherwise, the input is returned unchanged.
func TranslateIfResourcePath(input string) string {
	var resourceRelPath string

	stripped := strings.TrimPrefix(input, VirtualResourceRoot()+"/")
	if stripped != input {
		resourceRelPath = stripped
	} else {
		stripped := strings.TrimPrefix(input, AbsoluteVirtualResourceRoot()+"/")
		if stripped != input {
			resourceRelPath = stripped
		}
	}
	if resourceRelPath == "" {
		//not a resource
		return input
	}

	generatorRelPath := generatorForResourceFile[resourceRelPath]
	if generatorRelPath == "" {
		//either this is a static resource file or it's a resource file we don't
		//know anything about (sometimes diffs refer to resource files that were
		//deleted since the last apply run)
		return filepath.Join(RootDirectory(), "usr/share/holo/"+resourceRelPath)
	}
	return fmt.Sprintf("%s::%s",
		filepath.Join(RootDirectory(), "/usr/share/holo/generators/"+generatorRelPath),
		resourceRelPath,
	)
}
